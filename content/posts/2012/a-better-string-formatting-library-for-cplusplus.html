---
title: A better string formatting library for C++
date: 2012-12-12
aliases: ['/2012/12/12/a-better-string-formatting-library-for-cplusplus.html']
---

<div class="separator" style="clear:right; float:right; margin-left:1em; margin-bottom:1em">
  <img height="240" src=
  "http://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Calabi-Yau-alternate.png/240px-Calabi-Yau-alternate.png"
  title=
  "This image nicely illustrates the current situation with string formatting in C++."
  width="240">
</div>

<p>When I started learning C++ I kind of liked the <a href=
"http://en.wikipedia.org/wiki/Input/output_(C%2B%2B)">IOStreams</a> library.
It was safe, <a href=
"http://www.boost.org/doc/libs/1_37_0/libs/iostreams/doc/index.html">extensible</a>
and could work with user-defined types. This compared favorably with the
<code>printf</code> family of functions. However, as I started using C++ more
and more in my daily job I found out that IOStreams had serious flaws.
<a href="http://stackoverflow.com/a/3176640/471164">This answer</a> on Stack
Overflow nicely summarizes several issues with IOStreams:</p>

<ul>
  <li>Poor error handling</li>
  <li>Poor separation between formatting and I/O</li>
  <li>Poor support for i18n</li>
</ul>

<p>The popular <a href=
"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google C++
Style Guide</a> even permits the use of streams only for logging.</p>

<p>So I started looking for a better solution and discovered the following
libraries: <a href="http://www.boost.org/doc/libs/1_52_0/libs/format/">Boost
Format</a>, <a href=
"http://loki-lib.sourceforge.net/html/a00666.html">SafeFormat</a>, <a href=
"http://fastformat.sourceforge.net/">FastFormat</a> and <a href=
"https://github.com/c42f/tinyformat">tinyformat</a>. Unfortunately neither of
these entirely satisfied my needs so a few days ago when I was staying at
home with cold I wrote <a href="https://github.com/cppformat/cppformat">a new
formatting library</a> which is small, type safe and close to
<code>printf</code> in speed. In this and forthcoming posts I am going to
describe its features and how this library compares to others.</p>

<p>APIs of formatting libraries can be divided into two groups. The first
group uses functions with variable number of arguments. It includes
<code>printf</code> and friends, Fast Format and tinyformat. Here is an
example using <code>printf</code>:</p>

<pre>
printf("%s, %s %d\n", weekday, month, day);
</pre>

<p>One way to implement this kind of API is to use <a href=
"http://en.wikipedia.org/wiki/Stdarg.h">varargs</a>. This method is
inherently unsafe because the type information is not available to the callee
and it has to use some other mechanism such as a type field in a format
string like <code>printf</code> does. Another possibility is to use <a href=
"http://en.wikipedia.org/wiki/Variadic_template">variadic templates</a> which
unfortunately only available in C++11. For C++98 compatibility some libraries
like tinyformat provide multiple versions of the same function with different
number of arguments. The problem with this method is that it is difficult to
define your own function that wraps a formatting function. Tinyformat
provides a macro <a href=
"https://github.com/c42f/tinyformat#wrapping-tfmformat-inside-a-user-defined-format-function">
TINYFORMAT_WRAP_FORMAT</a> for this purpose which is used as follows:</p>

<pre>
#undef TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS
#define TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS int code,
TINYFORMAT_WRAP_FORMAT(
  void,                                        /* return type */
  error,                                       /* function name */
  /*empty*/,                                   /* function declaration
                                                  suffix (eg, const) */
  std::cerr << "error (code " << code << ")";, /* stuff before
                                                  format()*/
  std::cerr,                                   /* stream name */
  /*empty*/                                    /* stuff after
                                                  format() */
  )
#undef TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS
#define TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS
</pre>

<p>This is obviously far from ideal so I rejected variadic functions in the
core API although I am considering adding them in the future on top of existing
interface.</p>

<p>The second group of libraries uses overloaded operators such as
<code>operator&lt;&lt;</code> for passing arguments. It includes IOStreams,
Boost Format and SafeFormat. They all use different operators:</p>

<pre>
// IOStreams:
std::cout << weekday << ", " << month << " " << day << "\n";

// Boost Format:
std::string s = 
  str(boost::format("%1%, %2% %3%\n") % weekday % month % day);

// SafeFormat:
Loki::SPrintf(s, "%s, %d %d\n")(weekday)(month)(day);
</pre>

<p>Instead of yet another arbitrary operator choice, I decided to use the
conventional insertion operator <code>&lt;&lt;</code> since it is used by the
standard streams:</p>

<pre>
std::string s =
  str(fmt::Format("{0}, {1} {2}\n") << weekday << month << day);
</pre>

<p>As you can see the API is quite similar to Boost Format.
<code>Format</code> is a function that takes a format string as an argument
and returns a temporary object that accepts additional arguments via the
operator <code>&lt;&lt;</code>. The <code>str</code> function converts the
result into an <code>std::string</code>. There is also a <code>c_str</code>
function that converts the result into a C string which can be useful for
working with C code:</p>

<pre>
rmdir(c_str(fmt::Format("{0}.lock") << pid));
</pre>

<p>So far this is similar to existing APIs. What is different is the ability
to define your own functions that look exactly like <code>Format</code> but
do additional things, for example:</p>

<pre>
ReportError("File not found: {0}") << path;
</pre>

<p>Let's say I want to define a function <code>ReportError</code> that
formats and prints an error to <code>std::cerr</code> adding a newline. To
this end I need to create a small class (struct will do since it has only one
public member) that defines <code>operator()(const fmt::Writer &amp;)</code>
which does the output:</p>

<pre>
struct PrintError {
  void operator()(const fmt::Writer &w) const {
     std::cerr << "Error: " << w.str() << std::endl;
  }
};
</pre>

<p><code>Writer</code> is a class that does all the formatting and stores
the output in a buffer. The <code>str()</code> method converts the output to
<code>std::string</code>, there are other access methods as well. Now I can
define the <code>ReportError</code> function:</p>

<pre>
fmt::Formatter<PrintError> ReportError(const char *format) {
  return fmt::Formatter<PrintError>(format);
}
</pre>

<p><code>Formatter</code> is used only in wrapper functions like the
one above. It is responsible for receiving arguments via <code>operator<<</code>,
completing the format operation and calling a user supplied action like
<code>PrintError</code> after that.</p>

<p>As you can see creating wrappers is relatively easy. It doesn't require
any preprocessor tricks or defining functions for different number of
arguments. And once a wrapper function is defined it is as easy to use as
<code>fmt::Format</code>, in fact the latter is implemented in exactly the
same way.</p>

<p>The <code>Writer</code> class can also be used on its own if you need
to efficiently merge the output of multiple format operations, for
example:</p>

<pre>
fmt::Writer out;
for (int i = 0; i < 10; i++)
  out.Format("{0}") << i;
std::string s = out.str(); // s == 0123456789
</pre>

<p>This concludes the first and the most important part about the API. In the
next part I am going to write about performance and related design
aspects.</p>

<p>The library is available in <a href=
"https://github.com/cppformat/cppformat">this repository</a> on GitHub. Feel free
to use it and post your comments below.</p>
