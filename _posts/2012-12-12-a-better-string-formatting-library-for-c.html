---
layout: post
title: A better string formatting library for C++
date: 2012-12-12
comments: false
---

<h1>{{ page.title }}</h1>

<div class='post'>
  <div class="separator" style="clear: both; text-align: center;">
    <a href=
    "http://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Calabi-Yau-alternate.png/240px-Calabi-Yau-alternate.png"
    style=
    "clear:right; float:right; margin-left:1em; margin-bottom:1em"><img border=
    "0" height="240" src=
    "http://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Calabi-Yau-alternate.png/240px-Calabi-Yau-alternate.png"
    title=
    "This image nicely reflects the current situation with string formatting libraries in C++."
    width="240"></a>
  </div>

  <p>When I started learning C++ many years ago I kind of liked the <a href=
  "http://en.wikipedia.org/wiki/Input/output_(C%2B%2B)">IOStreams</a> library.
  It was safe, <a href=
  "http://www.boost.org/doc/libs/1_37_0/libs/iostreams/doc/index.html">extensible</a>
  and could work with user-defined types. This compared favorably with the
  <code>printf</code> family of functions. However, as I started using C++ more
  and more in my daily job I found out that IOStreams had serious flaws.
  <a href="http://stackoverflow.com/a/3176640/471164">This answer</a> on Stack
  Overflow nicely summarizes several issues with IOStreams:</p>

  <ul>
    <li>Poor error handling</li>

    <li>Poor separation between formatting and I/O</li>

    <li>Poor support for i18n</li>
  </ul>The popular <a href=
  "http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google C++
  Style Guide</a> even permits the use of streams only for logging.

  <p>So I started looking for a better solution and discovered the following
  libraries: <a href="http://www.boost.org/doc/libs/1_52_0/libs/format/">Boost
  Format</a>, <a href=
  "http://loki-lib.sourceforge.net/html/a00666.html">SafeFormat</a>, <a href=
  "http://fastformat.sourceforge.net/">FastFormat</a> and <a href=
  "https://github.com/c42f/tinyformat">tinyformat</a>. Unfortunately neither of
  these entirely satisfied my needs so a few days ago when I was staying at
  home with cold I wrote <a href="https://github.com/vitaut/format">a new
  formatting library</a> which is small, type safe and close to
  <code>printf</code> in speed. In this and forthcoming posts I am going to
  describe its features and how this library compares to others.</p>

  <h3>Part 1. API</h3>

  <p>APIs of formatting libraries can be divided into two groups. The first
  group uses functions with variable number of arguments. It includes
  <code>printf</code> and friends, Fast Format and tinyformat. Here is an
  example using <code>printf</code>:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>printf("%s, %s %d\n", weekday, month, day);<br>
</pre>

  <p>One way to implement this kind of API is to use <a href=
  "http://en.wikipedia.org/wiki/Stdarg.h">varargs</a>. This method is
  inherently unsafe because the type information is not available to the callee
  and it has to use some other mechanism such as a type field in a format
  string like <code>printf</code> does. Another possibility is to use <a href=
  "http://en.wikipedia.org/wiki/Variadic_template">variadic templates</a> which
  unfortunately only available in C++11. For C++98 compatibility some libraries
  like tinyformat provide multiple versions of the same function with different
  number of arguments. The problem with this method is that it is difficult to
  define your own function that wraps a formatting function. Tinyformat
  provides a macro <a href=
  "https://github.com/c42f/tinyformat#wrapping-tfmformat-inside-a-user-defined-format-function">
  TINYFORMAT_WRAP_FORMAT</a> for this purpose which is used as follows:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>#undef TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS<br>#define TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS int code,<br>TINYFORMAT_WRAP_FORMAT(<br>    void,                                        /* return type */<br>    error,                                       /* function name */<br>    /*empty*/,                                   /* function declaration suffix (eg, const) */<br>    std::cerr &lt;&lt; "error (code " &lt;&lt; code &lt;&lt; ")";, /* stuff before format()*/<br>    std::cerr,                                   /* stream name */<br>    /*empty*/                                    /* stuff after format() */<br>)<br>#undef TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS<br>#define TINYFORMAT_WRAP_FORMAT_EXTRA_ARGS<br>
</pre>This is obviously far from ideal so I rejected variadic functions in the
core API although I am considering adding them in the future on top of existing
interface.

  <p>The second group of libraries uses overloaded operators such as
  <code>operator&lt;&lt;</code> for passing arguments. It includes IOStreams,
  Boost Format and SafeFormat. They all use different operators:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>// IOStreams:<br>std::cout &lt;&lt; weekday &lt;&lt; ", " &lt;&lt; month &lt;&lt; " " &lt;&lt; day &lt;&lt; "\n";<br>// Boost Format:<br>std::string s =<br>  str(boost::format("%1%, %2% %3%\n") % weekday % month % day);<br>// SafeFormat:<br>Loki::SPrintf(s, "%s, %d %d\n")(weekday)(month)(day);<br>
</pre>

  <p>Instead of yet another arbitrary operator choice, I decided to use the
  conventional isertion operator <code>&lt;&lt;</code> since it is used by the
  standard streams:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>std::string s =<br>  str(fmt::Format("{0}, {1} {2}\n") &lt;&lt; weekday &lt;&lt; month &lt;&lt; day);<br>
</pre>

  <p>As you can see the API is quite similar to Boost Format.
  <code>Format</code> is a function that takes a format string as an argument
  and returns a temporary object that accepts additional arguments via the
  operator <code>&lt;&lt;</code>. The <code>str</code> function converts the
  result into an <code>std::string</code>. There is also a <code>c_str</code>
  function that converts the result into a C string which can be useful for
  working with C code:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>rmdir(c_str(fmt::Format("{0}.lock") &lt;&lt; pid));<br>
</pre>

  <p>So far this is similar to existing APIs. What is different is the ability
  to define your own functions that look exactly like <code>Format</code> but
  do additional things, for example:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>ReportError("File not found: {0}") &lt;&lt; path;<br>
</pre>

  <p>Let's say I want to define a function <code>ReportError</code> that
  formats and prints an error to <code>std::cerr</code> adding a newline. To
  this end I need to create a small class (struct will do since it has only one
  public member) that defines <code>operator()(const fmt::Formatter
  &amp;)</code> which does the output:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>struct PrintError {<br>  void operator()(const fmt::Formatter &amp;f) const {<br>    std::cerr &lt;&lt; "Error: " &lt;&lt; f.str() &lt;&lt; std::endl;<br>  }<br>};<br>
</pre>

  <p><code>Formatter</code> is a class that does all the formatting and stores
  the output in a buffer. The <code>str()</code> method converts the output to
  <code>std::string</code>, there are other access methods as well. Now I can
  define the <code>ReportError</code> function:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>fmt::ActiveFormatter&lt;PrintError&gt; ReportError(const char *format) {<br>  fmt::ActiveFormatter&lt;PrintError&gt; af(format);<br>  return af;<br>}<br>
</pre>

  <p><code>ActiveFormatter</code> is used only in wrapper functions like the
  one above. It is responsible for passing arguments to <code>Formatter</code>
  and calling a user supplied action like <code>PrintError</code> once
  formatting is complete.</p>

  <p>As you can see creating wrappers is relatively easy. It doesn't require
  any preprocessor tricks or defining functions for different number of
  arguments. And once a wrapper function is defined it is as easy to use as
  <code>fmt::Format</code>, in fact the latter is implemented in exactly the
  same way.</p>

  <p>The <code>Formatter</code> class can also be used on its own if you need
  to efficiently merge the output of multiple format operations, for
  example:</p>
  <pre class="brush: c++; gutter: false;" style="font-size:10px">
<br>fmt::Formatter format;<br>for (int i = 0; i &lt; 10; i++)<br>  format("{0}") &lt;&lt; i;<br>std::string s = format.str(); // s == 0123456789<br>
</pre>

  <p>This concludes the first and the most important part about the API. In the
  next part I am going to write about performance and related design
  aspects.</p>

  <p>The library is available in <a href=
  "https://github.com/vitaut/format">this repository</a> on GitHub. Feel free
  to use it and post your comments below.</p>
</div>

<h2>Comments</h2>

<div class='comments'></div>